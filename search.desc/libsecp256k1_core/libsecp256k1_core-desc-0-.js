searchState.loadedDescShard("libsecp256k1_core", 0, "Core libraries for libsecp256k1.\nCurve related structs.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUtilities to manipulate the secp256k1 curve parameters.\nA group element of the secp256k1 curve, in affine …\nAffine coordinate group element compact storage.\nContext for accelerating the computation of a<em>P + b</em>G.\nContext for accelerating the computation of a*G.\nField element for secp256k1.\nCompact field element storage.\nA group element of the secp256k1 curve, in jacobian …\nA 256-bit scalar value.\nSet r equal to the sum of a and b (with b given in affine …\nSet r equal to the sum of a and b (with b given in affine …\nSet r equal to the sum of a and b. If rzr is non-NULL, …\nSet r equal to the sum of a and b (with the inverse of b’…\nConvert a field element to a 32-byte big endian value. …\nConvert a scalar to a byte array.\nAccess bits from a scalar. All requested bits must belong …\nAccess bits from a scalar. Not constant time.\nConditionally add a power of two to a scalar. The result is\nSets a field element equal to zero, initializing all …\nClear a secp256k1_ge to prevent leaking sensitive …\nClear a secp256k1_gej to prevent leaking sensitive …\nClear a scalar to prevent the leak of sensitive data.\nIf flag is true, set *r equal to *a; otherwise leave it. …\nIf flag is true, set *r equal to *a; otherwise leave it. …\nCompare two field elements. Requires both inputs to be …\nConditionally negate a number, in constant time.\nSet r equal to the double of a. If rzr is not-NULL, r-&gt;z = …\nSet r equal to the double of a. If rzr is not-NULL, r-&gt;z = …\nCompare the X coordinate of a group element (jacobian).\nConvert a scalar to a byte array.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a scalar from an unsigned integer.\nCheck whether a group element’s y coordinate is a …\nInspect raw values of <code>ECMultContext</code>.\nInspect <code>ECMultGenContext</code> values.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSets a field element to be the (modular) inverse of …\nPotentially faster version of secp256k1_fe_inv, without …\nCheck whether a scalar is higher than the group order …\nCheck whether a group element is the point at infinity.\nCheck whether a group element is the point at infinity.\nCheck the “oddness” of a field element. Requires the …\nCheck whether a scalar equals one.\nChecks whether a field element is a quadratic residue.\nCheck whether a group element is valid (i.e., on the …\nVerify whether a field element is zero. Requires the input …\nCheck whether a scalar equals zero.\nSets a field element to be the product of two others. …\nMultiplies the passed field element with a small integer …\nCompute the additive inverse of this element. Takes the …\nSet a field element equal to the additive inverse of …\nSet r equal to the inverse of a (i.e., mirrored around the …\nCreate a new affine.\nCreate a new jacobian.\nCreate a new affine storage.\nGenerate a new <code>ECMultContext</code> on the heap. Note that this …\nGenerate a new <code>ECMultGenContext</code> on the heap. Note that …\nCreate a new <code>ECMultContext</code> from raw values.\nCreate a new <code>ECMultGenContext</code> from raw values.\nNormalize a field element.\nNormalize a field element, without constant-time guarantee.\nWeakly normalize a field element: reduce it magnitude to 1,\nVerify whether a field element represents zero i.e. would …\nVerify whether a field element represents zero i.e. would …\nRescale a jacobian point by b which must be non-zero. …\nSet a field element equal to 32-byte big endian value. If …\nSet a scalar from a big endian byte array, return whether …\nSet a group element (jacobian) equal to another which is …\nSet a group element equal to another which is given in …\nSet a group element (jacobian) equal to the point at …\nSet a field element equal to a small integer. Resulting …\nSet a scalar to an unsigned integer.\nSet a group element (affine) equal to the point with the …\nSet a group element (affine) equal to the point with the …\nSet a group element equal to the point with given X and Y …\nShift a scalar right by some amount strictly between 0 and …\nSets a field element to be the square of another. Requires …\nIf a has a square root, it is computed in r and 1 is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")